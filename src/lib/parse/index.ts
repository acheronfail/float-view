import * as fflate from 'fflate';

import { parseFloatControlCsv } from './float-control';
import { parseFloatyJson } from './floaty';
import { DataSource, Units, type RowWithIndex } from './types';
import { parseVescToolCsv } from './vesc';

export class ParseError extends Error {
  constructor(
    public readonly message: string,
    public readonly cause: unknown,
  ) {
    super(message);
  }
}

export interface ParseResult {
  data: RowWithIndex[];
  units: Units;
  source: DataSource;
  error?: Error;
}

export enum SupportedMimeTypes {
  /** VESC Tool or Float Control CSV */
  Csv = 'text/csv',
  /** VESC Tool or Float Control Zipped CSV */
  Zip1 = 'application/zip',
  Zip2 = 'application/x-zip-compressed',
  /** Floaty's JSON */
  Json = 'application/json',
}

export const supportedMimeTypes = Object.values<string>(SupportedMimeTypes);
export const supportedMimeTypeString = supportedMimeTypes.join(',');

async function parseCsv(input: string | File): Promise<ParseResult> {
  if (typeof input !== 'string') {
    const first100Bytes = await input.slice(0, 100).text();
    const semiColonCount = first100Bytes.split(';').length - 1;

    // VESC Tool delimits by semi-colon, so we use that to detect if it's CSV
    // generated by VESC Tool or Float Control
    if (semiColonCount > 1) {
      return parseVescToolCsv(input);
    }
  }

  return await parseFloatControlCsv(input);
}

export async function parse(file: File): Promise<ParseResult> {
  const lowerName = file.name.toLowerCase();
  if (file.type === SupportedMimeTypes.Zip1 || file.type === SupportedMimeTypes.Zip2 || lowerName.endsWith('.zip')) {
    const fileMap = fflate.unzipSync(new Uint8Array(await file.arrayBuffer()));
    const fileList = Object.keys(fileMap);
    if (fileList.length !== 1) {
      return {
        source: DataSource.None,
        data: [],
        units: Units.Metric,
        error: new ParseError('Expected a zip containing a single CSV file from Float Control!', file),
      };
    }

    const unzippedBytes = fileMap[fileList[0]!]!;
    return await parseCsv(new TextDecoder().decode(unzippedBytes));
  }

  if (file.type === SupportedMimeTypes.Csv || lowerName.endsWith('.csv')) {
    return await parseCsv(file);
  }

  if (file.type === SupportedMimeTypes.Json || lowerName.endsWith('.json')) {
    return await parseFloatyJson(file);
  }

  return {
    source: DataSource.None,
    data: [],
    units: Units.Metric,
    error: new ParseError('Unrecognised file!', file),
  };
}
